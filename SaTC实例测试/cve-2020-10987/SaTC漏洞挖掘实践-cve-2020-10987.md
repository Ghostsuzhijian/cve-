# SaTC漏洞挖掘实践

## 一、漏洞挖掘原理

### 常见方法

fuzzing（动态测试方法）

但是将fuzzing这种传统pc领域非常成熟的像afl这些框架用在这种设备上的话就面临一个问题，你需要把它模拟起来。现在很难有一个非常统一的高效的这种恢复的环境。

静态分析

学术界比较推崇的是符号执行，然而实际应用过程中，执行的时候面临着很多的问题，第一个是它的开销非常大，并且会碰到循环约束条件如何结束的问题，导致路径爆炸。

你还需要去准确的模拟这种程序的上下文，比如跨进程的问题。如果你多进程通信的话怎么来准确的模拟，因为你是在没有运行程序的状态下，现在的符号执行是一种混合符号执行的状态，也称之为动态符号执行。就是传统的静态符号之前基本上是不可用的。

SaTC：方法来源于共享关键字，基于这个关键字开展污点分析。我们明白一个典型的路由器，比如注册功能，这里是一个前端的界面，然后右侧的话就是它对应的二进制，像前端的话，你用户发送的数据会由于前端代码的这种解析来给到它一个标签，然后后端的话会有相应的关键词出现，所以说这是最开始我们为什么提出这种方法的一种出发点。

![图片](https://bbs.kanxue.com/upload/attach/202111/236762_T3382U38WGGNF7U.jpg)

左端是它前端的发现漏洞的一个代码，是js代码，我们看到它用一个dos内容这样一个关键字来标注这段数据的，然后右边是相应的二进制程序，它经过一系列非常复杂的函数调用之后，在最后他执行了一个命令叫from set usb unload，这个函数里面它有个doSystem，所以在这里的话它没有去过滤发送过来的device name对应的字段内容，所以就产生的命令注入。

从上述例子可以看出，如果我们有一个非常高效的方法，从前端可以把这些关键字提取出来的话，那么给我们带来的直接的收益。就是我们在整个污点分析过程当中，就可以跳过这些没有太多意义的处理函数。

所以带给我们的启发就是，如果我们拥有了这些关键字的话，会极大缩减我们符号执行的路径，就是让它的可用性得到了进一步提升。所以我们的一个非常简单的想法就是说在前端的js文件中，用户输入被一个字符串dos等号来标记，然后在后端的二进制之中几乎完全相同的字符串dos内容用于提取数据包装对应的system。

所以两个同时出现的关键字就是我们标题里面所讲的教学的key words，所以我们的方法就是这样子来的。

![图片](https://bbs.kanxue.com/upload/attach/202111/236762_3S39MESZ9Z8VW6J.jpg)

这个方法同样也面临众多挑战，第一个挑战就是如何识别这种前端文件中的关键字。第二个就是如何定位这些关键字在后端的二进制里面的处理位置。第三个就是如何跟踪大量的用户输入的相关路径，检测是否存在安全漏洞

![图片](https://bbs.kanxue.com/upload/attach/202111/236762_GZ2U7K5YNCFCUC4.jpg)

![图片](https://bbs.kanxue.com/upload/attach/202111/236762_ET4A8BEP56QPJWK.jpg)

基于两类，一个是基于前端经验得到的这种筛选模式，还有一个是基于文件和字符串出现的频率。通用字符串这里是没啥用的。

## 二、漏洞挖掘实战

我们使用上述方法来实例挖掘一个tenda的命令注入漏洞。

可以直接使用docker拉取镜像来获得配置

```
# 拉取docker镜像
docker pull smile0304/satc
# 进入docker环境
docker run -it smile0304/satc:V1.0
# 安装pip requirement
pip install -r requirement.txt
```

使用如下命令来分析，这需要一定的时间。

```
python satc.py -d /home/satc/SaTC/tendaac15/squashfs-root/ -o /home/satc/SaTC/res_ac15 --ghidra_script=ref2sink_cmdi -b httpd --taint_check
```

分析的结果会存放在如下的文件中。

![bfe3f6dc580fad260d3baf1ace48754](C:\Users\robot_i\Documents\WeChat Files\wxid_pkzhj2rzqvwr22\FileStorage\Temp\bfe3f6dc580fad260d3baf1ace48754.png)

查看该文件

![d1380e640709a867b05eaa3897ae300](C:\Users\robot_i\Documents\WeChat Files\wxid_pkzhj2rzqvwr22\FileStorage\Temp\d1380e640709a867b05eaa3897ae300.png)

在0xa68f8处发现了命令注入漏洞

使用ida查看

![58baadf7d9d1c72c3660e5693065f62](C:\Users\robot_i\Documents\WeChat Files\wxid_pkzhj2rzqvwr22\FileStorage\Temp\58baadf7d9d1c72c3660e5693065f62.png)

果然看到了类system函数

## 手工进行确认

### 首先使用qemu进行系统模拟

![e51768219b12f46bfe4e66e37ff0441](C:\Users\robot_i\Documents\WeChat Files\wxid_pkzhj2rzqvwr22\FileStorage\Temp\e51768219b12f46bfe4e66e37ff0441.png)

首先下载如下文件至同一文件夹

```shell
wget https://people.debian.org/~aurel32/qemu/armhf/debian_wheezy_armhf_standard.qcow2
wget https://people.debian.org/~aurel32/qemu/armhf/initrd.img-3.2.0-4-vexpress
wget https://people.debian.org/~aurel32/qemu/armhf/vmlinuz-3.2.0-4-vexpress
```

为了使宿主机和qemu通信，这里使用桥接的模式，安装tunctl

```shell
sudo apt-get install uml-utilities
```

配置虚拟网卡

```
sudo tunctl -t br0 -u root          //br0是网卡名字 root是你已有账户名
sudo ifconfig br0 192.168.0.1/24     //给br0配置IP地址，这里配什么地址都可以
```

使用如下命令打开

```shell
qemu-system-arm -M vexpress-a9 -kernel vmlinuz-3.2.0-4-vexpress -initrd initrd.img-3.2.0-4-vexpress -drive if=sd,file=debian_wheezy_armhf_standard.qcow2 -append "root=/dev/mmcblk0p2 console=ttyAMA0" -net nic -net tap,ifname=br0,script=no,downscript=no -nographic
```

```shell
-M              //选择虚拟机
​
-drive          //定义存储驱动器
​
file=           //定义镜像文件
​
-net nic        //创建客户机网卡
​
-net tap        //创建tap设备，以桥接方式跟宿主机通信
​
ifname=br0      //tap设备与br0虚拟网卡进行桥接通信
​
-nographic      //以非图形化模式启动
​
-append         //内核启动附加参数
​
console=ttyAMA0 //console指向串口
```

```shell
进入之后配置eth0来通信
ifconfig eth0 192.168.0.2/24
```

要保证他们在同一网段，这样才可以通信

在宿主机上找到结构后的固件sq文件系统，将文件传入客户机中。

```shell
scp -r squashfs-root/ root@192.168.0.2:/
```

在客户机上使用chroot切换文件夹

```shell
chroot squashfs-root sh
```

然后,启动

```
cd bin
httpd
```

会发现一直卡在welcome to

![2b642ffed3a67916c97d0ecd13d6f3d](C:\Users\robot_i\Documents\WeChat Files\wxid_pkzhj2rzqvwr22\FileStorage\Temp\2b642ffed3a67916c97d0ecd13d6f3d.png)

这里需要进行patched

使用ida打开httpd

![1b45ccdb9dd2fe5ccd7a70ff1e7f547](C:\Users\robot_i\Documents\WeChat Files\wxid_pkzhj2rzqvwr22\FileStorage\Temp\1b45ccdb9dd2fe5ccd7a70ff1e7f547.png)

进行这两处的patched，（BGT是大于则跳转的意思）

之后会发现ip出错

![2343239c1f80d3a75b08731f5a33849](C:\Users\robot_i\Documents\WeChat Files\wxid_pkzhj2rzqvwr22\FileStorage\Temp\2343239c1f80d3a75b08731f5a33849.png)

```shell
cp -rf ./webroot_ro/* ./webroot/
使用上述命令后变为如下
```

![0750756e3ae915ecc2dfcbfabb8d41e](C:\Users\robot_i\Documents\WeChat Files\wxid_pkzhj2rzqvwr22\FileStorage\Temp\0750756e3ae915ecc2dfcbfabb8d41e.png)

这里查阅后发现需要添加网桥

![31b5eaa8bd3a7f7b9da3aa24629e6fa](C:\Users\robot_i\Documents\WeChat Files\wxid_pkzhj2rzqvwr22\FileStorage\Temp\31b5eaa8bd3a7f7b9da3aa24629e6fa.png)

查看有无br0网桥，若有删除，并新建一个，配置如上ip

![629a8463d38487e6214bc441315b832](C:\Users\robot_i\Documents\WeChat Files\wxid_pkzhj2rzqvwr22\FileStorage\Temp\629a8463d38487e6214bc441315b832.png)

成功启动

直接访问

```url
http://192.168.0.3/status_usb.html
```

发现Unmount按钮会一闪而过，只要在web开发者工具中禁止如下url就可以

```
http://192.168.0.3/goform/GetUsbCfg*
```

![1a99483c3f4335c13dff9ea5abddfb8](C:\Users\robot_i\Documents\WeChat Files\wxid_pkzhj2rzqvwr22\FileStorage\Temp\1a99483c3f4335c13dff9ea5abddfb8.png)

![70543f5bc15dafa12ec909efb78d546](C:\Users\robot_i\Documents\WeChat Files\wxid_pkzhj2rzqvwr22\FileStorage\Temp\70543f5bc15dafa12ec909efb78d546.png)

使用burp抓包并点击按钮

如下包结构

![1f7d0b0ca8e3aaeff894988656f0d31](C:\Users\robot_i\Documents\WeChat Files\wxid_pkzhj2rzqvwr22\FileStorage\Temp\1f7d0b0ca8e3aaeff894988656f0d31.png)

这里的deviceName就是命令注入点

构造POC，使用python监听8000端口

![11b673bd50b28f5717536334ecea5b2](C:\Users\robot_i\Documents\WeChat Files\wxid_pkzhj2rzqvwr22\FileStorage\Temp\11b673bd50b28f5717536334ecea5b2.png)

监听结果如下

![967e1496863f91bb388cf5e416d12f6](C:\Users\robot_i\Documents\WeChat Files\wxid_pkzhj2rzqvwr22\FileStorage\Temp\967e1496863f91bb388cf5e416d12f6.png)

系统模拟显示如下

![91742607b5b8e6ea480c18182f2e006](C:\Users\robot_i\Documents\WeChat Files\wxid_pkzhj2rzqvwr22\FileStorage\Temp\91742607b5b8e6ea480c18182f2e006.png)

利用成功。

